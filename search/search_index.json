{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Welcome to MkDocs"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"git_usage/","text":"Development Work Flow Short Lesson The majority of teams using git have a work flow that looks similar to the four well known work flows: Git Flow GitHub Flow GitLab Flow Trunk Based Development Git Development - the Shaken Fist Way The Shaken Fist developers have chosen Trunk Based Development. Branch Types master branch This is the development trunk. All feature branches are branched from master and merged to master . feature branches Short-lived, generally a few days. Normally only one developer. When presented to the team, it is expected to pass the linter and unit tests. It is normal that other team members suggest changes/improvements before merging. release-vX.X branches Only created when a release requires patches (hot-fixes). Commits to this branch are cherry-picks from master . It is not expected that many commits are made to this branch. If many commits are required to a release branch then this indicates the need for another release. One day the project might desire a develop branch to ensure that master is always production ready. This can be useful when adding and maturing multiple inter-dependant features. At this stage, it is not required and would lead to more complexity. At this of project maturity, that complexity would be extra effort with the possibility of errors without a significant return. Process Feature branches Feature/Bug branches have a prefix consisting of the GitHub issue number - no need for the word bug or issue. The feature branch developer should squash commits to remove WIP commits before creating a Pull Request. It is preferably that each remaining commit passes testing/CI. Merging Commits are not squashed when merged to master Not squashing commits maintains history of multiple issues being solved. Pull Request related commits remain grouped and can be understood as a single merge Release branch Only necessary bug fixes are cherry-picked from master to an existing release-vX.X branch. Too many cherry-picked commits to a Release branch If a large number of commits appear desirable on a release branch, it is probably an indication that another minor release would be a better idea. If another release is not desired because master contains unstable features then either CI needs improving or that feature requires more work and should not be in master .","title":"Development Work Flow"},{"location":"git_usage/#development-work-flow","text":"","title":"Development Work Flow"},{"location":"git_usage/#short-lesson","text":"The majority of teams using git have a work flow that looks similar to the four well known work flows: Git Flow GitHub Flow GitLab Flow Trunk Based Development","title":"Short Lesson"},{"location":"git_usage/#git-development-the-shaken-fist-way","text":"The Shaken Fist developers have chosen Trunk Based Development.","title":"Git Development - the Shaken Fist Way"},{"location":"git_usage/#branch-types","text":"master branch This is the development trunk. All feature branches are branched from master and merged to master . feature branches Short-lived, generally a few days. Normally only one developer. When presented to the team, it is expected to pass the linter and unit tests. It is normal that other team members suggest changes/improvements before merging. release-vX.X branches Only created when a release requires patches (hot-fixes). Commits to this branch are cherry-picks from master . It is not expected that many commits are made to this branch. If many commits are required to a release branch then this indicates the need for another release. One day the project might desire a develop branch to ensure that master is always production ready. This can be useful when adding and maturing multiple inter-dependant features. At this stage, it is not required and would lead to more complexity. At this of project maturity, that complexity would be extra effort with the possibility of errors without a significant return.","title":"Branch Types"},{"location":"git_usage/#process","text":"","title":"Process"},{"location":"git_usage/#feature-branches","text":"Feature/Bug branches have a prefix consisting of the GitHub issue number - no need for the word bug or issue. The feature branch developer should squash commits to remove WIP commits before creating a Pull Request. It is preferably that each remaining commit passes testing/CI.","title":"Feature branches"},{"location":"git_usage/#merging","text":"Commits are not squashed when merged to master Not squashing commits maintains history of multiple issues being solved. Pull Request related commits remain grouped and can be understood as a single merge","title":"Merging"},{"location":"git_usage/#release-branch","text":"Only necessary bug fixes are cherry-picked from master to an existing release-vX.X branch.","title":"Release branch"},{"location":"git_usage/#too-many-cherry-picked-commits-to-a-release-branch","text":"If a large number of commits appear desirable on a release branch, it is probably an indication that another minor release would be a better idea. If another release is not desired because master contains unstable features then either CI needs improving or that feature requires more work and should not be in master .","title":"Too many cherry-picked commits to a Release branch"},{"location":"namespace_auth/","text":"Namespace Context and Authentication Namespaces All resources (instances/networks/interfaces) are assigned to a Namespace. All requests to Shaken Fist have a Namespace context. Only requests in the \"system\" Namespace are able to access resources in other (foreign) Namespaces. The Namespace \"system\" is reserved. Authentication A Namespace is accessed by supplying a valid \"Key\" (password). Namespaces can have multiple Keys. Each Key has a label referred to as a \"Key Name\". The Key Name is not specified during authentication. The Key Name \"service_key\" is reserved. API Request Authentication The authentication endpoint /auth is used to obtain a token to authenticate future API interaction. To obtain the token, the authentication request is made specifying the Namespace and the Key. The Key Name is not required (nor important). The response contains the (JWT) token to be used as a Bearer token for the actual API request. Internally, Shaken Fist determines the Namespace of each API request from the token. Authentication tokens expire after a fixed period of time (nominally 15 minutes). Interaction Name spaces can be created from within the \"system\" Namespace. The creation of a Namespace requires that a Key and it's Key Name are specified with the creation request. Keys do not have to be unique. A Key collision within a Namespace has no security consequences. Key Names are only unique within a Namespace. The purpose of the Key Name is to supply a handle to enable deletion of a Key. Actions are not logged against Key Names. Inter-Node Authentication Requests between Shaken Fist nodes use the same authentication system as external API requests. When a node makes an API request to another node, the originating node will create (or reuse) a \"service key\" specific to the Namespace of the original request. When a request is made from the \"system\" Namespace for a resource in a different Namespace, the API request is made using the foreign Namespace and the foreign Namespace service key.","title":"Namespace auth"},{"location":"namespace_auth/#namespace-context-and-authentication","text":"","title":"Namespace Context and Authentication"},{"location":"namespace_auth/#namespaces","text":"All resources (instances/networks/interfaces) are assigned to a Namespace. All requests to Shaken Fist have a Namespace context. Only requests in the \"system\" Namespace are able to access resources in other (foreign) Namespaces. The Namespace \"system\" is reserved.","title":"Namespaces"},{"location":"namespace_auth/#authentication","text":"A Namespace is accessed by supplying a valid \"Key\" (password). Namespaces can have multiple Keys. Each Key has a label referred to as a \"Key Name\". The Key Name is not specified during authentication. The Key Name \"service_key\" is reserved.","title":"Authentication"},{"location":"namespace_auth/#api-request-authentication","text":"The authentication endpoint /auth is used to obtain a token to authenticate future API interaction. To obtain the token, the authentication request is made specifying the Namespace and the Key. The Key Name is not required (nor important). The response contains the (JWT) token to be used as a Bearer token for the actual API request. Internally, Shaken Fist determines the Namespace of each API request from the token. Authentication tokens expire after a fixed period of time (nominally 15 minutes).","title":"API Request Authentication"},{"location":"namespace_auth/#interaction","text":"Name spaces can be created from within the \"system\" Namespace. The creation of a Namespace requires that a Key and it's Key Name are specified with the creation request. Keys do not have to be unique. A Key collision within a Namespace has no security consequences. Key Names are only unique within a Namespace. The purpose of the Key Name is to supply a handle to enable deletion of a Key. Actions are not logged against Key Names.","title":"Interaction"},{"location":"namespace_auth/#inter-node-authentication","text":"Requests between Shaken Fist nodes use the same authentication system as external API requests. When a node makes an API request to another node, the originating node will create (or reuse) a \"service key\" specific to the Namespace of the original request. When a request is made from the \"system\" Namespace for a resource in a different Namespace, the API request is made using the foreign Namespace and the foreign Namespace service key.","title":"Inter-Node Authentication"},{"location":"standards/","text":"Concepts and Standards Ensuring a Common Language within the code base This document records the standards and common language used within the Shaken Fist software system. It should also record why the choice was made. (This is actually just notes to save our future selves from tripping over the same problems.) Memory Memory is measured in MiB All references to memory size are stored/transmitted in MiB Gigabytes can be too big if you want a lot of small machines. Kilobytes is just too many numbers to type. Interactions The libvirt API measures memory in KiB. Therefore, interactions with the library need to be careful to convert from MiB to KiB.","title":"Standards"},{"location":"standards/#concepts-and-standards","text":"","title":"Concepts and Standards"},{"location":"standards/#ensuring-a-common-language-within-the-code-base","text":"This document records the standards and common language used within the Shaken Fist software system. It should also record why the choice was made. (This is actually just notes to save our future selves from tripping over the same problems.)","title":"Ensuring a Common Language within the code base"},{"location":"standards/#memory","text":"Memory is measured in MiB All references to memory size are stored/transmitted in MiB Gigabytes can be too big if you want a lot of small machines. Kilobytes is just too many numbers to type.","title":"Memory"},{"location":"standards/#interactions","text":"The libvirt API measures memory in KiB. Therefore, interactions with the library need to be careful to convert from MiB to KiB.","title":"Interactions"}]}